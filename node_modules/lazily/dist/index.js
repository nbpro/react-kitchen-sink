"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Seq {
    constructor(seq) {
        this.seq = seq;
    }
    static of(list) {
        return new Seq(sequence(list));
    }
    *[Symbol.iterator]() {
        for (const i of this.seq()) {
            yield i;
        }
    }
    concat(seq) {
        return new Seq(concat(this, seq));
    }
    every(fn) {
        return every(this.seq, fn);
    }
    exit(fn, result) {
        return new Seq(exit(this.seq, fn, result));
    }
    exitAfter(fn, result) {
        return new Seq(exitAfter(this.seq, fn, result));
    }
    filter(fn) {
        return new Seq(filter(this.seq, fn));
    }
    find(fn) {
        return find(this.seq, fn);
    }
    first(predicate) {
        return first(this.seq, predicate);
    }
    flatMap(fn) {
        return new Seq(flatMap(this.seq, fn));
    }
    includes(item) {
        return includes(this.seq, item);
    }
    last(predicate) {
        return last(this.seq, predicate);
    }
    map(fn) {
        return new Seq(map(this.seq, fn));
    }
    reduce(fn, initialValue, fnShortCircuit) {
        return reduce(this.seq, fn, initialValue, fnShortCircuit);
    }
    reverse() {
        return new Seq(reverse(this.seq));
    }
    slice(begin, end) {
        return new Seq(slice(this.seq, begin, end));
    }
    some(fn) {
        return some(this.seq, fn);
    }
    sort(fn) {
        return new Seq(sort(this.seq, fn));
    }
    toArray() {
        return toArray(this.seq);
    }
}
exports.Seq = Seq;
function sequence(list) {
    return function* gen() {
        for (const item of list) {
            yield item;
        }
    };
}
exports.sequence = sequence;
function concat(iterable, newIterable) {
    return function* () {
        for (const i of iterable) {
            yield i;
        }
        for (const j of newIterable) {
            yield j;
        }
    };
}
exports.concat = concat;
function every(seq, fn) {
    let i = 0;
    for (const item of seq()) {
        if (!fn(item, i, seq)) {
            return false;
        }
        i++;
    }
    return true;
}
exports.every = every;
function exit(seq, fn, result) {
    return function* () {
        let i = 0;
        for (const item of seq()) {
            if (fn(item, i, seq)) {
                return result;
            }
            yield item;
            i++;
        }
    };
}
exports.exit = exit;
function exitAfter(seq, fn, result) {
    return function* () {
        let i = 0;
        for (const item of seq()) {
            if (fn(item, i, seq)) {
                yield item;
                return result;
            }
            yield item;
            i++;
        }
    };
}
exports.exitAfter = exitAfter;
function find(seq, fn) {
    let i = 0;
    for (const item of seq()) {
        if (fn(item, i, seq)) {
            return item;
        }
        i++;
    }
}
exports.find = find;
function filter(seq, fn) {
    return function* () {
        let i = 0;
        for (const item of seq()) {
            if (fn(item, i, seq)) {
                yield item;
            }
            i++;
        }
    };
}
exports.filter = filter;
function first(_seq, predicate) {
    const seq = predicate ? filter(_seq, predicate) : _seq;
    for (const item of seq()) {
        return item;
    }
}
exports.first = first;
function flatMap(seq, fn) {
    return function* () {
        let i = 0;
        for (const item of seq()) {
            const childSeq = fn(item, i, seq);
            for (const child of childSeq) {
                yield child;
            }
            i++;
        }
    };
}
exports.flatMap = flatMap;
function includes(seq, what) {
    return some(seq, item => item === what);
}
exports.includes = includes;
function last(_seq, predicate) {
    const seq = predicate ? filter(_seq, predicate) : _seq;
    let prev;
    for (const item of seq()) {
        prev = item;
    }
    return prev;
}
exports.last = last;
function map(seq, fn) {
    return function* () {
        let i = 0;
        for (const item of seq()) {
            yield fn(item, i, seq);
            i++;
        }
    };
}
exports.map = map;
function reduce(seq, fn, initialValue, fnShortCircuit) {
    let acc = initialValue;
    let i = 0;
    for (const item of seq()) {
        acc = fn(acc, item, i, seq);
        if (fnShortCircuit && fnShortCircuit(acc, item, i, seq)) {
            return acc;
        }
        i++;
    }
    return acc;
}
exports.reduce = reduce;
function reverse(seq) {
    return function* () {
        const all = toArray(seq).reverse();
        for (const item of all) {
            yield item;
        }
    };
}
exports.reverse = reverse;
function slice(seq, begin, end) {
    return function* () {
        let i = 0;
        for (const item of seq()) {
            if (i >= begin && (!end || i < end)) {
                yield item;
            }
            i++;
            if (i === end) {
                return;
            }
        }
    };
}
exports.slice = slice;
function some(seq, fn) {
    let i = 0;
    for (const item of seq()) {
        if (fn(item, i, seq)) {
            return true;
        }
        i++;
    }
    return false;
}
exports.some = some;
function sort(seq, fn) {
    return function* () {
        const all = toArray(seq).sort(fn);
        for (const item of all) {
            yield item;
        }
    };
}
exports.sort = sort;
function toArray(seq) {
    const results = [];
    for (const item of seq()) {
        results.push(item);
    }
    return results;
}
exports.toArray = toArray;
//# sourceMappingURL=index.js.map