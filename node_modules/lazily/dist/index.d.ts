export declare type SequenceFnType<T> = () => IterableIterator<T>;
export declare type PredicateType<T> = (val: T, i?: number, seq?: SequenceFnType<T>) => boolean;
export declare class Seq<T> implements Iterable<T> {
    seq: SequenceFnType<T>;
    static of<T>(list: Iterable<T>): Seq<T>;
    constructor(seq: SequenceFnType<T>);
    [Symbol.iterator](): Generator<T, void, unknown>;
    concat(seq: Iterable<T>): Seq<T>;
    every(fn: PredicateType<T>): boolean;
    exit(fn: PredicateType<T>, result?: any): Seq<T>;
    exitAfter(fn: PredicateType<T>, result?: any): Seq<T>;
    filter(fn: PredicateType<T>): Seq<T>;
    find(fn: PredicateType<T>): T | undefined;
    first(predicate?: PredicateType<T>): T | undefined;
    flatMap<TOut>(fn: (val: T, i: number, seq: SequenceFnType<T>) => Iterable<TOut>): Seq<TOut>;
    includes(item: T): boolean;
    last(predicate?: PredicateType<T>): T | undefined;
    map<TOut>(fn: (val: T, i: number, seq: SequenceFnType<T>) => TOut): Seq<TOut>;
    reduce<TAcc>(fn: (acc: TAcc, item: T, i?: number, seq?: SequenceFnType<T>) => TAcc, initialValue: TAcc, fnShortCircuit?: (acc: TAcc, item?: T, i?: number, seq?: SequenceFnType<T>) => boolean): TAcc;
    reverse(): Seq<T>;
    slice(begin: number, end?: number): Seq<T>;
    some(fn: PredicateType<T>): boolean;
    sort(fn: (a: T, b: T) => number): Seq<T>;
    toArray(): Array<T>;
}
export declare function sequence<T>(list: Iterable<T>): SequenceFnType<T>;
export declare function concat<T>(iterable: Iterable<T>, newIterable: Iterable<T>): SequenceFnType<T>;
export declare function every<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): boolean;
export declare function exit<T>(seq: SequenceFnType<T>, fn: PredicateType<T>, result?: any): SequenceFnType<T>;
export declare function exitAfter<T>(seq: SequenceFnType<T>, fn: PredicateType<T>, result?: any): SequenceFnType<T>;
export declare function find<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): T | undefined;
export declare function filter<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): SequenceFnType<T>;
export declare function first<T>(_seq: SequenceFnType<T>, predicate?: PredicateType<T>): T | undefined;
export declare function flatMap<T, TOut>(seq: SequenceFnType<T>, fn: (val: T, i: number, seq: SequenceFnType<T>) => Iterable<TOut>): SequenceFnType<TOut>;
export declare function includes<T>(seq: SequenceFnType<T>, what: T): boolean;
export declare function last<T>(_seq: SequenceFnType<T>, predicate?: PredicateType<T>): T | undefined;
export declare function map<T, TOut>(seq: SequenceFnType<T>, fn: (val: T, i: number, seq: SequenceFnType<T>) => TOut): SequenceFnType<TOut>;
export declare function reduce<T, TAcc>(seq: SequenceFnType<T>, fn: (acc: TAcc, item: T, i: number, seq: SequenceFnType<T>) => TAcc, initialValue: TAcc, fnShortCircuit?: (acc: TAcc, item?: T, i?: number, seq?: SequenceFnType<T>) => boolean): TAcc;
export declare function reverse<T>(seq: SequenceFnType<T>): SequenceFnType<T>;
export declare function slice<T>(seq: SequenceFnType<T>, begin: number, end?: number): SequenceFnType<T>;
export declare function some<T>(seq: SequenceFnType<T>, fn: PredicateType<T>): boolean;
export declare function sort<T>(seq: SequenceFnType<T>, fn: (a: T, b: T) => number): SequenceFnType<T>;
export declare function toArray<T>(seq: SequenceFnType<T>): Array<T>;
